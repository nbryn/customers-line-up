import {SerializedError, createSlice, isAnyOf} from '@reduxjs/toolkit';

import {
    createBooking,
    deleteBookingForBusiness,
    deleteBookingForUser,
} from '../../features/booking/BookingApi';
import {
    createBusiness,
    fetchAllBusinesses,
    fetchBusinessesTypes,
    updateBusinessInfo,
} from '../../features/business/BusinessApi';
import {createEmployee, removeEmployee} from '../../features/employee/EmployeeApi';
import {sendMessage} from '../../features/message/MessageApi';
import {deleteTimeSlot, generateTimeSlots} from '../../features/timeslot/TimeSlotApi';
import {
    login,
    register,
    fetchUser,
    fetchUsersNotEmployedByBusiness,
    updateUserInfo,
} from '../../features/user/UserApi';
import {useAppSelector, type RootState} from '../../app/Store';
import { BaseQueryApi, QueryStatus } from '@reduxjs/toolkit/query';
import { AxiosResponse } from 'axios';
import Cookies from 'js-cookie';
import { Configuration, QueryApi } from '../../autogenerated';

const EMPLOYEE_CREATED_MSG = 'Employee Created - Go to my employees to see your employees';

const TIMESLOT_DELETED_MSG = 'Time slot Deleted';
const TIMESLOTS_GENERATED_MSG = 'Success! Press see time slots to manage time slots.';

const MESSAGE_SEND = 'Message successfully send';

const USER_UPDATED_MSG = 'Info Updated.';
const LOGIN_FAILED_MSG = 'Wrong Email/Password';

export type ToastInfo = {
    buttonText: string;
    navigateTo: string;
};

interface ApiState {
    error: boolean;
    message: string;
    toastInfo?: ToastInfo;
}

const initialState: ApiState = {
    error: false,
    message: '',
    toastInfo: undefined,
};

export async function apiQuery<T>(
    query: (queryApi: QueryApi) => Promise<AxiosResponse<T, any>>,
    api: BaseQueryApi,
    successInfo?: Omit<ApiState, 'error'>
): Promise<T> {
    const queryApi = new QueryApi(new Configuration({accessToken: Cookies.get('access_token')}));
    try {
        const response = await query(queryApi);
        if (successInfo) {
            api.dispatch(setApiState(successInfo));
        }

        return response.data;
    } catch (error) {
        const err = error as SerializedError;
        api.dispatch(setApiState({message: err.message, error: true}));
        return {error} as any;
    }
}

export async function apiMutation(
    mutation: () => Promise<AxiosResponse<void, any>>,
    api: BaseQueryApi,
    successInfo?: Omit<ApiState, 'error'>
): Promise<void> {
    try {
        await mutation();
        if (successInfo) {
            api.dispatch(setApiState(successInfo));
        }
    } catch (error) {
        const err = error as SerializedError;
        api.dispatch(setApiState({message: err.message, error: true}));
    }
}

export const isLoading = useAppSelector((state) => {
    return Object.values(state.api.queries).some((query) => {
        return query && query.status === QueryStatus.pending;
    });
});

export const apiSlice = createSlice({
    name: 'api',
    initialState,
    reducers: {
        setApiState: (state: ApiState) => {
            state = state;
        },
        clearApiState: (state) => {
            state.error = false;
            state.message = '';
            state.toastInfo = undefined;
        },
    },
    extraReducers: (builder) => {
        builder
            .addCase(createEmployee.fulfilled, (state) => {
                state.error = false;
                state.message = EMPLOYEE_CREATED_MSG;
                state.toastInfo = {
                    buttonText: 'My Employees',
                    navigateTo: '/business/employees/manage',
                };
            })

            .addCase(generateTimeSlots.fulfilled, (state) => {
                state.error = false;
                state.message = TIMESLOTS_GENERATED_MSG;
                state.toastInfo = {
                    buttonText: 'See time slots',
                    navigateTo: '/business/timeslots/manage',
                };
            })

            .addCase(login.rejected, (state) => {
                state.error = true;
                state.message = LOGIN_FAILED_MSG;
            })

            .addCase(deleteTimeSlot.fulfilled, (state) => {
                state.error = false;
                state.message = TIMESLOT_DELETED_MSG;
            })

            .addCase(updateUserInfo.fulfilled, (state) => {
                state.error = false;
                state.message = USER_UPDATED_MSG;
            })

            .addCase(sendMessage.fulfilled, (state) => {
                state.error = false;
                state.message = MESSAGE_SEND;
            })

            .addMatcher(
                isAnyOf(
                    fetchAllBusinesses.fulfilled,
                    fetchBusinessesTypes.fulfilled,
                    removeEmployee.fulfilled,
                    login.fulfilled,
                    register.fulfilled,
                    fetchUser.fulfilled
                ),
                (state) => {
                    state.error = false;
                    state.message = '';
                }
            )

            .addMatcher(
                isAnyOf(
                    createBooking.pending,
                    deleteBookingForBusiness.pending,
                    deleteBookingForUser.pending,
                    createBusiness.pending,
                    fetchAllBusinesses.pending,
                    fetchBusinessesTypes.pending,
                    updateBusinessInfo.pending,
                    createEmployee.pending,
                    removeEmployee.pending,
                    deleteTimeSlot.pending,
                    generateTimeSlots.pending,
                    fetchUsersNotEmployedByBusiness.pending,
                    login.pending,
                    register.pending,
                    updateUserInfo.pending,
                    sendMessage.pending,
                    fetchUser.pending
                ),
                (state) => {
                     = true;
                }
            )

            .addMatcher(
                isAnyOf(
                    deleteBookingForBusiness.rejected,
                    deleteBookingForUser.rejected,
                    fetchAllBusinesses.rejected,
                    createBusiness.rejected,
                    fetchAllBusinesses.rejected,
                    fetchBusinessesTypes.rejected,
                    updateBusinessInfo.rejected,
                    createEmployee.rejected,
                    removeEmployee.rejected,
                    deleteTimeSlot.rejected,
                    generateTimeSlots.rejected,
                    fetchUsersNotEmployedByBusiness.rejected,
                    register.rejected,
                    updateUserInfo.rejected,
                    sendMessage.rejected,
                    fetchUser.rejected
                ),
                (state, action) => {
                     = false;
                    state.error = true;
                    state.message = action.error.message!;
                }
            );
    },
});

export const {clearApiState, setApiState} = apiSlice.actions;

export const selectApiState = (state: RootState) => state.api;

export default apiSlice.reducer;
